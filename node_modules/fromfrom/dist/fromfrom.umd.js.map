{"version":3,"file":"fromfrom.umd.js","sources":["../src/transforms/concat.ts","../src/transforms/distinct.ts","../src/transforms/filter.ts","../src/transforms/flatMap.ts","../src/transforms/groupBy.ts","../src/transforms/map.ts","../src/transforms/prepend.ts","../src/utils.ts","../src/transforms/reverse.ts","../src/transforms/skip.ts","../src/transforms/skipWhile.ts","../src/transforms/sortBy.ts","../src/transforms/take.ts","../src/transforms/takeWhile.ts","../src/transforms/without.ts","../src/Sequence.ts","../src/ObjectIterable.ts","../src/fromfrom.ts"],"sourcesContent":["export function* concat<TItem, TOther>(\n  source: Iterable<TItem>,\n  ...others: Iterable<TOther>[]\n) {\n  yield* source;\n  for (const other of others) {\n    yield* other;\n  }\n}\n","export function* distinct<TItem>(iterable: Iterable<TItem>) {\n  const unique = new Set();\n\n  for (const item of iterable) {\n    if (!unique.has(item)) {\n      unique.add(item);\n      yield item;\n    }\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* filter<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  for (const item of iterable) {\n    if (predicate(item)) {\n      yield item;\n    }\n  }\n}\n","import { MapFn } from \"../types\";\n\nexport function* flatMap<TItem, TOther>(\n  iterable: Iterable<TItem>,\n  mapperFn: MapFn<TItem, TOther[]>\n) {\n  for (const item of iterable) {\n    const sequence = mapperFn(item);\n    yield* sequence;\n  }\n}\n","import { KeySelectorFn, MapFn, Grouping } from \"../types\";\n\nexport function* groupBy<TItem, TKey, TElement>(\n  iterable: Iterable<TItem>,\n  keySelector: KeySelectorFn<TItem, TKey>,\n  elementSelector?: MapFn<TItem, TElement>\n): IterableIterator<Grouping<TKey, TElement>> {\n  const groups = new Map<TKey, TElement[]>();\n\n  for (const item of iterable) {\n    const key = keySelector(item);\n    const value = elementSelector\n      ? elementSelector(item)\n      : ((item as unknown) as TElement);\n\n    let group = groups.get(key);\n    if (!group) {\n      group = [];\n      groups.set(key, group);\n    }\n\n    group.push(value);\n  }\n\n  for (const keyItemsPair of groups.entries()) {\n    yield {\n      key: keyItemsPair[0],\n      items: keyItemsPair[1],\n    };\n  }\n}\n","import { MapFn } from \"../types\";\n\nexport function* map<TItem, TResult>(\n  source: Iterable<TItem>,\n  mapFn: MapFn<TItem, TResult>\n) {\n  for (const item of source) {\n    yield mapFn(item);\n  }\n}\n","export function* prepend<TItem, TOther>(\n  source: Iterable<TItem>,\n  ...others: Iterable<TOther>[]\n) {\n  for (const other of others) {\n    yield* other;\n  }\n  yield* source;\n}\n","/**\n * Copies items from the given iterable into an array\n */\nexport function copyIntoAnArray<T>(iterable: Iterable<T>) {\n  // Optimization for arrays, as .slice() by far fastest way to\n  // create a shallow copy https://jsbench.me/pmk2aqrlo1\n  if (Array.isArray(iterable)) {\n    return iterable.slice();\n  }\n\n  // With iterables for-of loop is the fastest https://jsbench.me/pwk2ar61ei\n  const result = [];\n  for (const item of iterable) {\n    result.push(item);\n  }\n\n  return result;\n}\n\n/**\n * Creates an iterable from given generator function\n *\n * @param generatorFn\n * @param args\n */\nexport const iterableFromGenerator = <TItem>(\n  generatorFn: Function,\n  args?: any[]\n): Iterable<TItem> => ({\n  [Symbol.iterator]: (): Iterator<TItem> => generatorFn.apply(undefined, args),\n});\n","import { copyIntoAnArray } from \"../utils\";\n\nexport function* reverse<TItem>(iterable: Iterable<TItem>) {\n  const items = copyIntoAnArray(iterable);\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    yield items[i];\n  }\n}\n","export function* skip<TItem>(iterable: Iterable<TItem>, howMany: number) {\n  let numSkipped = 0;\n\n  for (const item of iterable) {\n    if (numSkipped < howMany) {\n      numSkipped++;\n      continue;\n    }\n\n    yield item;\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* skipWhile<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  let startTaking = false;\n\n  for (const item of iterable) {\n    if (startTaking) {\n      yield item;\n    } else if (!predicate(item)) {\n      yield item;\n      startTaking = true;\n    }\n  }\n}\n","import { ComparerFn } from \"../types\";\nimport { copyIntoAnArray } from \"../utils\";\n\nexport function* sortBy<TItem>(\n  iterable: Iterable<TItem>,\n  comparer: ComparerFn<TItem>\n) {\n  yield* copyIntoAnArray(iterable).sort(comparer);\n}\n","export function* take<TItem>(iterable: Iterable<TItem>, howMany: number) {\n  if (howMany < 1) {\n    return;\n  }\n\n  let numTaken = 0;\n\n  for (const item of iterable) {\n    numTaken++;\n    yield item;\n\n    if (numTaken >= howMany) {\n      break;\n    }\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* takeWhile<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  for (const item of iterable) {\n    if (!predicate(item)) {\n      break;\n    }\n\n    yield item;\n  }\n}\n","import { ComparePredicate } from \"../types\";\n\nexport function* without<TItem>(\n  iterator: Iterable<TItem>,\n  withoutItems: Iterable<TItem>,\n  comparePredicate: ComparePredicate<TItem>\n) {\n  // cache already found results\n  const cache = new Set();\n\n  outer: for (const item of iterator) {\n    // fast path, this item was already found, don't loop\n    if (cache.has(item)) continue;\n    // slow path, loop over each item in the set, determine if it matches the ComparePredicate\n    for (const withoutItem of withoutItems) {\n      // if the item is found, add it to the cache and skip the item\n      if (comparePredicate(item, withoutItem)) {\n        cache.add(item);\n        continue outer;\n      }\n    }\n\n    // we can safely yield the item\n    yield item;\n  }\n}\n","import {\n  KeySelectorFn,\n  ComparerFn,\n  PredicateFn,\n  MapFn,\n  CallbackFn,\n  Grouping,\n  ReduceCallbackFn,\n  NumberKeyedObject,\n  StringKeyedObject,\n  ComparePredicate,\n} from \"./types\";\nimport { concat } from \"./transforms/concat\";\nimport { distinct } from \"./transforms/distinct\";\nimport { filter } from \"./transforms/filter\";\nimport { flatMap } from \"./transforms/flatMap\";\nimport { groupBy } from \"./transforms/groupBy\";\nimport { map } from \"./transforms/map\";\nimport { prepend } from \"./transforms/prepend\";\nimport { reverse } from \"./transforms/reverse\";\nimport { skip } from \"./transforms/skip\";\nimport { skipWhile } from \"./transforms/skipWhile\";\nimport { sortBy } from \"./transforms/sortBy\";\nimport { take } from \"./transforms/take\";\nimport { takeWhile } from \"./transforms/takeWhile\";\nimport { without } from \"./transforms/without\";\nimport { copyIntoAnArray, iterableFromGenerator } from \"./utils\";\n\nconst identityPredicateFn = (x: any): boolean => x;\n\nconst defaultComparer = <TKey>(a: TKey, b: TKey) => {\n  if (a === b) {\n    return 0;\n  }\n\n  if (a < b) {\n    return -1;\n  }\n\n  return 1;\n};\n\n/**\n * A sequence of items\n */\nexport class Sequence<TItem> implements Iterable<TItem> {\n  constructor(protected _iterable: Iterable<TItem>) {}\n\n  [Symbol.iterator] = (): Iterator<TItem> => this._iterable[Symbol.iterator]();\n\n  /**\n   * Returns a new sequence that contains the items in the current sequence\n   * and items from the given iterable.\n   *\n   * @example\n   * ```typescript\n   * // Returns sequence with values 1, 2, 3, 4\n   * from([1, 2]).concat([3, 4]);\n   * ```\n   */\n  concat<TOther>(...others: Iterable<TOther>[]): Sequence<TItem | TOther> {\n    return this._sequenceFromGenerator<TItem | TOther>(concat, others);\n  }\n\n  /**\n   * Returns unique values in the sequence. Uniqueness is checked using\n   * the '===' operator.\n   *\n   * @example\n   * ```typescript\n   * // Returns a sequence with the values 4, 5\n   * from([4, 4, 5, 4]).distinct();\n   * ```\n   */\n  distinct(): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(distinct);\n  }\n\n  /**\n   * Checks that all items in the sequence pass the test implemented by the\n   * provided function.\n   *\n   * @example\n   * ```typescript\n   * // Returns false\n   * from([-1, 4, 5, 6]).every(x => x >= 0);\n   * ```\n   */\n  every(predicate: PredicateFn<TItem> = identityPredicateFn): boolean {\n    for (const item of this._iterable) {\n      if (!predicate(item)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new sequence where items are filtered out for which the\n   * predicate function returns a falsy value.\n   *\n   * @example\n   * ```typescript\n   * // Returns a squence with the value -1\n   * from([-1, 4, 5, 6]).filter(x => x < 0);\n   * ```\n   */\n  filter(predicate: PredicateFn<TItem>): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(filter, [predicate]);\n  }\n\n  /**\n   * Returns the value of the first element in the sequence that satisfies the\n   * provided testing function. Otherwise undefined is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns 4\n   * from([2, 4, 6]).find(x => x === 4);\n   * ```\n   */\n  find(predicate: PredicateFn<TItem>): TItem | undefined {\n    for (const item of this._iterable) {\n      if (predicate(item)) {\n        return item;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the first element of the sequence or undefined if\n   * the sequence is empty.\n   *\n   * @example\n   * ```typescript\n   * // Returns 1\n   * from([1, 3, 5]).first();\n   * ```\n   */\n  first(): TItem | undefined {\n    for (const item of this._iterable) {\n      return item;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * First maps each element of the sequence using the given mapping function,\n   * then flattens the result into a new sequence.\n   *\n   * @example\n   * ```typescript\n   * // Returns [1, 2, 3, 4, 5, 6]\n   * from([1, 3, 5]).flatMap(x => [x, x + 1]).toArray();\n   * ```\n   */\n  flatMap<TResultItem>(\n    mapperFn: MapFn<TItem, TResultItem[]>\n  ): Sequence<TResultItem> {\n    return this._sequenceFromGenerator<TResultItem>(flatMap, [mapperFn]);\n  }\n\n  /**\n   * Calls the given callback function with each item in the sequence.\n   *\n   * @example\n   * ```typescript\n   * // Logs 1, 2 and 3 to console\n   * from([1, 2, 3]).forEach(i => console.log(i));\n   * ```\n   */\n  forEach(callback: CallbackFn<TItem>): void {\n    for (const item of this._iterable) {\n      callback(item);\n    }\n  }\n\n  /**\n   * Groups the items in the sequence using the given item's key\n   *\n   * @param key Key to be used for the grouping\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\");\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\n   * //     { name: \"John\", gender: \"M\" },\n   * //     { name: \"Mike\", gender: \"M\" }\n   * //   ]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\n   * //     { name: \"Lisa\", gender: \"F\" },\n   * //     { name: \"Mary\", gender: \"F\" }\n   * //   ]\n   * // }\n   * ```\n   */\n  groupBy<TKey extends keyof TItem>(\n    key: TKey\n  ): Sequence<Grouping<TItem[TKey], TItem>>;\n  /**\n   * Groups the items in the sequence by keys returned by the given\n   * keySelector function.\n   *\n   * @param keySelector A function to extract the key for each element.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(user => user.gender);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\n   * //     { name: \"John\", gender: \"M\" },\n   * //     { name: \"Mike\", gender: \"M\" }\n   * //   ]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\n   * //     { name: \"Lisa\", gender: \"F\" },\n   * //     { name: \"Mary\", gender: \"F\" }\n   * //   ]\n   * // }\n   * ```\n   */\n  groupBy<TKey>(\n    keySelector: KeySelectorFn<TItem, TKey>\n  ): Sequence<Grouping<TKey, TItem>>;\n  /**\n   * Groups the items of a sequence according to a specified key and\n   * projects the elements for each group by using a specified function.\n   *\n   * @param key Key to be used for the grouping\n   * @param elementSelector A function to map each source element to an element in an Grouping<TKey,TElement>.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\", user => user.name);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\"John\", \"Mike\"]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\"Lisa\", \"Mary\"]\n   * // }\n   * ```\n   */\n  groupBy<TKey extends keyof TItem, TElement>(\n    key: TKey,\n    elementSelector: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TItem[TKey], TItem>>;\n  /**\n   * Groups the elements of a sequence according to a specified key selector\n   * function and projects the elements for each group by using a specified\n   * function.\n   *\n   * @param keySelector A function to extract the key for each element.\n   * @param elementSelector A function to map each source element to an element in an Grouping<TKey,TElement>.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\", user => user.name);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\"John\", \"Mike\"]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\"Lisa\", \"Mary\"]\n   * // }\n   * ```\n   */\n  groupBy<TKey, TElement>(\n    keySelector: KeySelectorFn<TItem, TKey>,\n    elementSelector: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TKey, TElement>>;\n  groupBy<TKey, TElement>(\n    keySelector: KeySelectorFn<TItem, TKey> | string,\n    elementSelector?: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TKey, TElement>> {\n    if (typeof keySelector === \"string\") {\n      keySelector = createSelectByKey<TItem>(keySelector);\n    }\n\n    return this._sequenceFromGenerator<Grouping<TKey, TElement>>(groupBy, [\n      keySelector,\n      elementSelector,\n    ]);\n  }\n\n  /**\n   * Determines whether the sequence includes the given element,\n   * returning true or false as appropriate. The check is done\n   * using '==='.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([1, 2, 3]).includes(3);\n   * ```\n   */\n  includes(searchItem: TItem): boolean {\n    for (const item of this._iterable) {\n      if (item === searchItem) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the sequence is empty, false otherwise.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([]).isEmpty();\n   * ```\n   */\n  isEmpty(): boolean {\n    return !this.some(() => true);\n  }\n\n  /**\n   * Returns the first element of the sequence or undefined if\n   * the sequence is empty.\n   *\n   * @example\n   * ```typescript\n   * // Returns 5\n   * from([1, 3, 5]).last();\n   * ```\n   */\n  last(): TItem | undefined {\n    const items = this.toArray();\n\n    return items.length === 0 ? undefined : items[items.length - 1];\n  }\n\n  /**\n   * Maps the sequence to a new sequence where each item is converted\n   * to a new value using the given mapper function.\n   *\n   * @example\n   * ```typescript\n   * // Returns [2, 4, 6]\n   * from([1, 2, 3]).map(x => x * 2);\n   * ```\n   */\n  map<TResultItem>(mapFn: MapFn<TItem, TResultItem>): Sequence<TResultItem> {\n    return this._sequenceFromGenerator<TResultItem>(map, [mapFn]);\n  }\n\n  /**\n   * Maps each item in the sequence to an object composed of the picked\n   * object properties.\n   *\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 1, name: \"John\", age: 31, active: true },\n   * { id: 2, name: \"Jane\", age: 32, active: false },\n   * { id: 3, name: \"Luke\", age: 33, active: false },\n   * { id: 4, name: \"Mary\", age: 34, active: true },\n   * ];\n   *\n   * // Returns a Sequence of { name: 'John' }, { name: 'Jane' }, { name: 'Luke' }, { name: 'Mary' }\n   * from(users).pick(\"name\");\n   * ```\n   */\n  pick<TKeys extends keyof TItem>(\n    ...keys: TKeys[]\n  ): Sequence<{ [P in TKeys]: TItem[P] }> {\n    return this.map((item: TItem) => {\n      const result: any = {};\n\n      for (const key of keys) {\n        if (key in item) {\n          result[key] = item[key];\n        }\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * This method yields the elements from the provided items first, followed by the items in the\n   * underlying sequence.\n   *\n   * @param items The provided set of items that should be in the prepended to the Sequence.\n   *\n   * @example\n   * ```ts\n   * // returns [4, 5, 6, 1, 2, 3]\n   * from([1, 2, 3])\n   *   .prepend([4, 5, 6])\n   *   .toArray();\n   * ```\n   */\n  prepend(...items: Iterable<TItem>[]): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(prepend, items);\n  }\n\n  /**\n   * Executes a reducer function on each item in the sequence resulting\n   * in a single output value.\n   *\n   * @example\n   * ```typescript\n   * // Returns a 15\n   * from([1, 2, 3, 4, 5]).reduce((x, acc) => acc+x, 0)\n   * ```\n   */\n  reduce<TResult>(\n    callback: ReduceCallbackFn<TResult, TItem>,\n    accumulator: TResult\n  ): TResult {\n    for (const item of this._iterable) {\n      accumulator = callback(accumulator, item);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Reverses the order of the items in the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [3, 2, 1]\n   * from([1, 2, 3]).reverse().toArray();\n   * ```\n   */\n  reverse(): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(reverse);\n  }\n\n  /**\n   * Skips the first N items in the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [3, 4]\n   * from([1, 2, 3, 4]).skip(2);\n   * ```\n   */\n  skip(howMany: number): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(skip, [howMany]);\n  }\n\n  /**\n   * Bypasses elements in a sequence as long as a specified condition is true\n   * and then returns the remaining elements.\n   *\n   * @param predicate  A function to test each element for a condition.\n   *\n   * @example\n   * ```ts\n   * // Returns [3, 4, 5]\n   * from([1, 2, 3, 4, 5])\n   *   .skipWhile(i => i < 3)\n   *   .toArray();\n   * ```\n   */\n  skipWhile(predicate: PredicateFn<TItem>): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(skipWhile, [predicate]);\n  }\n\n  /**\n   * Returns true if sequence contains an element for which the given\n   * predicate returns a truthy value.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([1, 2, 3]).some(x => x === 1)\n   * ```\n   */\n  some(predicate: PredicateFn<TItem> = identityPredicateFn): boolean {\n    for (const item of this._iterable) {\n      if (predicate(item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sorts the elements of a sequence in ascending order according to a key\n   * by using a specified comparer.\n   *\n   * @param keySelector  A function to extract a key from an element.\n   * @param comparer     A function to compare the keys\n   */\n  /**\n   * @example\n   * ```typescript\n   * // Returns a Sequence of 1, 2, 3\n   * from([1, 3, 2]).sortBy()\n   * ```\n   */\n  sortBy(): OrderedSequence<TItem>;\n  /**\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 2, name: \"Jane\" },\n   * { id: 4, name: \"Mary\" },\n   * { id: 1, name: \"John\" },\n   * { id: 3, name: \"Luke\" },\n   * ];\n   *\n   * // Returns a Sequence of\n   * //  { id: 1, name: 'John' },\n   * //  { id: 2, name: 'Jane' },\n   * //  { id: 3, name: 'Luke' },\n   * //  { id: 4, name: 'Mary' }\n   * from(users).sortBy(user => user.id)\n   * ```\n   */\n  sortBy<TKey>(\n    keySelector: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem>;\n  /**\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 2, name: \"Jane\" },\n   * { id: 4, name: \"Mary\" },\n   * { id: 1, name: \"John\" },\n   * { id: 3, name: \"Luke\" },\n   * ];\n   *\n   * // Returns a Sequence of\n   * // Returns a Sequence of\n   * // { id: 4, name: 'Mary' },\n   * // { id: 3, name: 'Luke' },\n   * // { id: 2, name: 'Jane' },\n   * // { id: 1, name: 'John' }\n   * from(users).sortBy(user => user.id)\n   * ```\n   */\n  sortBy<TKey>(\n    keySelector?: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem> {\n    const compareFn = createCompareFn(false, keySelector, comparer);\n\n    return new OrderedSequence(this._iterable, compareFn);\n  }\n\n  /**\n   * Sorts the elements of a sequence in descending order according to a key\n   * by using a specified comparer.\n   *\n   * @param keySelector  A function to extract a key from an element.\n   * @param comparer     A function to compare the keys\n   *\n   * @example\n   * ```typescript\n   * // Returns a Sequence of 3, 2, 1\n   * from([1, 3, 2]).sortByDescending()\n   * ```\n   */\n  sortByDescending<TKey = TItem>(\n    keySelector?: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem> {\n    const compareFn = createCompareFn(true, keySelector, comparer);\n\n    return new OrderedSequence(this._iterable, compareFn);\n  }\n\n  /**\n   * Sums the elements in the sequence.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns 6\n   * from([1, 2, 3]).sum();\n   * ```\n   */\n  sum<TItem extends number>(): number;\n  /**\n   * Sums the elements in the sequence\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns \"abc\"\n   * from([\"a\", \"b\", \"c\"]).sum();\n   * ```\n   */\n  sum<TItem extends string>(): string;\n  /**\n   * Maps the elements in the sequence using the valueSelector and sums them\n   * together.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @param valueSelector  A function to select a value from an element.\n   *\n   * @example\n   * ```typescript\n   * // Returns 2\n   * from([true, false, true]).sum(x => x ? 1 : 0);\n   * ```\n   */\n  sum<TResult extends number>(valueSelector: MapFn<TItem, TResult>): number;\n  /**\n   * Maps the elements in the sequence using the valueSelector and sums them\n   * together.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @param valueSelector  A function to select a value from an element.\n   *\n   * @example\n   * ```typescript\n   * // Returns \"101\"\n   * from([true, false, true]).sum(x => x ? \"1\" : \"0\");\n   * ```\n   */\n  sum<TResult extends string>(valueSelector: MapFn<TItem, TResult>): string;\n  sum<TResult>(valueSelector?: MapFn<TItem, TResult>): number | string {\n    let result: any | undefined = undefined;\n\n    for (const item of this._iterable) {\n      let itemToSum = valueSelector ? valueSelector(item) : item;\n\n      if (result === undefined) {\n        result = itemToSum as any;\n      } else {\n        result +=\n          typeof (itemToSum as unknown) === \"number\"\n            ? itemToSum\n            : String(itemToSum);\n      }\n    }\n\n    return result === undefined ? 0 : result;\n  }\n\n  /**\n   * Takes the firt N items from the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [1, 2]\n   * from([1, 2, 3, 4]).take(2);\n   * ```\n   */\n  take(howMany: number): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(take, [howMany]);\n  }\n\n  /**\n   * Returns elements from a sequence as long as a specified condition is true,\n   * and then skips the remaining elements.\n   *\n   * @param predicate  A function to test each element for a condition.\n   *\n   * @example\n   * ```ts\n   * // Returns [1, 2]\n   * from([1, 2, 3, 4, 5])\n   *   .takeWhile(i => i < 3)\n   *   .toArray();\n   * ```\n   */\n  takeWhile(predicate: PredicateFn<TItem>) {\n    return this._sequenceFromGenerator<TItem>(takeWhile, [predicate]);\n  }\n\n  /**\n   * Returns elements from a sequence as long as they don't exist in the specified iterable items.\n   *\n   * @param items     The provided set of items that should not be in the returned Sequence.\n   * @param predicate The optional predicate that determines if two TItem items are equal.\n   *\n   * @example\n   * ```ts\n   * // returns [2, 4, 6]\n   * from([1, 2, 3, 4, 5, 6])\n   *   .without([1, 3, 5])\n   *   .toArray();\n   *\n   * // returns [{ id: 1 }, { id: 3 }]\n   * from([{ id: 1 }, { id: 2 }, { id: 3 }])\n   *   .without([{ id: 2 }], (a, b) => a.id === b.id)\n   *   .toArray();\n   * ```\n   */\n  without(\n    items: Iterable<TItem>,\n    predicate?: ComparePredicate<TItem>\n  ): Sequence<TItem> {\n    if (!predicate) {\n      const withoutSet = new Set(items);\n      return this.filter((item: TItem) => !withoutSet.has(item));\n    } else {\n      return this._sequenceFromGenerator<TItem>(without, [items, predicate]);\n    }\n  }\n\n  /**\n   * Converts the sequence to an array\n   *\n   * @example\n   * ```typescript\n   * // Return [1, 2, 3]\n   * from([1, 2, 3]).toArray();\n   * ```\n   */\n  toArray(): TItem[] {\n    return copyIntoAnArray(this._iterable);\n  }\n\n  /**\n   * Converts the sequence to a Map using the given keySelectorFn and\n   * possible elementSelectorFn.\n   *\n   * @example\n   * ```typescript\n   * // Returns map with elements:\n   * // 1 -> { id: 1, name: \"John\" }\n   * // 2 -> { id: 2, name: \"Jane\"}\n   * const users = [{ id: 1, name: \"John\" }, { id: 2, name: \"Jane\"}]\n   * from(users).toMap(u => u.id);\n   * ```\n   *\n   * @param keySelectorFn\n   * @param elementSelectorFn\n   */\n  toMap<TKey, TElement = TItem>(\n    keySelectorFn: MapFn<TItem, TKey>,\n    elementSelectorFn?: MapFn<TItem, TElement>\n  ): Map<TKey, TElement> {\n    const map = new Map<TKey, TElement>();\n\n    for (const item of this._iterable) {\n      const key = keySelectorFn(item);\n      const value = elementSelectorFn ? elementSelectorFn(item) : item;\n\n      map.set(key, value as TElement);\n    }\n\n    return map;\n  }\n\n  /**\n   * Converts the sequence to an object using the given keySelectorFn and\n   * possible elementSelectorFn.\n   *\n   * @example\n   * ```typescript\n   * // Returns an object:\n   * // {\n   * //   \"John\": { id: 1, name: \"John\" },\n   * //   \"Jane\": { id: 2, name: \"Jane\"}\n   * // }\n   * const users = [{ id: 1, name: \"John\" }, { id: 2, name: \"Jane\"}]\n   * from(users).toObject(u => u.name);\n   * ```\n   *\n   * @param keySelectorFn\n   * @param elementSelectorFn\n   */\n  toObject(keySelectorFn: MapFn<TItem, string>): StringKeyedObject<TItem>;\n  toObject(keySelectorFn: MapFn<TItem, number>): NumberKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, string>,\n    elementSelectorFn: MapFn<TItem, TElement>\n  ): StringKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, number>,\n    elementSelectorFn: MapFn<TItem, TElement>\n  ): NumberKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, string> | MapFn<TItem, number>,\n    elementSelectorFn?: MapFn<TItem, TElement>\n  ):\n    | StringKeyedObject<TItem>\n    | NumberKeyedObject<TItem>\n    | StringKeyedObject<TElement>\n    | NumberKeyedObject<TElement> {\n    const object: any = {};\n\n    for (const item of this._iterable) {\n      const key = keySelectorFn(item);\n      const value = elementSelectorFn ? elementSelectorFn(item) : item;\n\n      object[key] = value;\n    }\n\n    return object;\n  }\n\n  /**\n   * Converts the sequence to a Set\n   *\n   * @example\n   * ```typescript\n   * // Return a Set with elements 1, 2, 3\n   * from([1, 1, 2, 3]).toSet();\n   * ```\n   */\n  toSet(): Set<TItem> {\n    return new Set(this._iterable);\n  }\n\n  private _sequenceFromGenerator<TResult = TItem>(\n    factoryFn: Function,\n    restArgs?: any[]\n  ) {\n    const iterableArg = [this._iterable];\n\n    return new Sequence<TResult>(\n      iterableFromGenerator<TResult>(\n        factoryFn,\n        restArgs ? iterableArg.concat(restArgs) : iterableArg\n      )\n    );\n  }\n}\n\n/**\n * Ordered sequence of elements\n */\nexport class OrderedSequence<TItem> extends Sequence<TItem> {\n  private _comparer: ComparerFn<TItem>;\n\n  constructor(\n    private _iterableToSort: Iterable<TItem>,\n    comparer: ComparerFn<TItem>\n  ) {\n    super(iterableFromGenerator(sortBy, [_iterableToSort, comparer]));\n\n    this._comparer = comparer;\n  }\n\n  thenBy<TOtherKey>(\n    keySelector: KeySelectorFn<TItem, TOtherKey>,\n    comparer?: ComparerFn<TOtherKey>\n  ): OrderedSequence<TItem> {\n    const thenComparer = createCompareFn(false, keySelector, comparer);\n    const compareFn = createChainedCompareFn(this._comparer, thenComparer);\n\n    return new OrderedSequence(this._iterableToSort, compareFn);\n  }\n\n  thenByDescending<TOtherKey>(\n    keySelector: KeySelectorFn<TItem, TOtherKey>,\n    comparer?: ComparerFn<TOtherKey>\n  ): OrderedSequence<TItem> {\n    const thenComparer = createCompareFn(true, keySelector, comparer);\n    const compareFn = createChainedCompareFn(this._comparer, thenComparer);\n\n    return new OrderedSequence(this._iterableToSort, compareFn);\n  }\n}\n\n/**\n * Creates a compare function that sorts TItems either ascending or descending\n * using the given key selector and comparer.\n *\n * @param descending  Sort descending or ascending\n * @param keySelector Optional function to select the key that is used for sorting\n * @param comparer    Optional comparer function to compare the keys\n */\nconst createCompareFn = <TItem, TKey>(\n  descending: boolean,\n  keySelector?: KeySelectorFn<TItem, TKey>,\n  comparer?: ComparerFn<TKey>\n) => {\n  const compareFn = comparer || defaultComparer;\n\n  return keySelector\n    ? (a: TItem, b: TItem) =>\n        descending\n          ? compareFn(keySelector(b), keySelector(a))\n          : compareFn(keySelector(a), keySelector(b))\n    : (a: TItem, b: TItem) =>\n        descending ? defaultComparer(b, a) : defaultComparer(a, b);\n};\n\n/**\n * Chains two compare functions. First sort by firstCompare. If items\n * are equal, then sorts by secondCompare.\n *\n * @param firstCompare\n * @param secondCompare\n */\nconst createChainedCompareFn = <TItem>(\n  firstCompare: ComparerFn<TItem>,\n  secondCompare: ComparerFn<TItem>\n) => (a: TItem, b: TItem) => {\n  const firstResult = firstCompare(a, b);\n\n  return firstResult === 0 ? secondCompare(a, b) : firstResult;\n};\n\nconst createSelectByKey = <TItem>(key: string) => (item: TItem) =>\n  key in item ? (item as any)[key] : undefined;\n","import { NumberKeyedObject, StringKeyedObject } from \"./types\";\nimport { iterableFromGenerator } from \"./utils\";\n\n/**\n * Creates an iterable from object, that iterates the object\n * as key value pairs.\n */\nexport function createObjectIterable<T>(\n  object: NumberKeyedObject<T>\n): Iterable<[number, T]>;\nexport function createObjectIterable<T>(\n  object: StringKeyedObject<T>\n): Iterable<[string, T]>;\nexport function createObjectIterable<T>(\n  object: StringKeyedObject<T> | NumberKeyedObject<T>\n): any {\n  return iterableFromGenerator(objectIterator, [object]);\n}\n\nfunction* objectIterator(object: any) {\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      const value = object[key];\n\n      yield [key, value] as any;\n    }\n  }\n}\n","/**\n * Entrypoint of the library\n */\nimport { Sequence } from \"./Sequence\";\nimport { createObjectIterable } from \"./ObjectIterable\";\nimport { StringKeyedObject, NumberKeyedObject } from \"./types\";\n\nexport function from<T>(iterable: Iterable<T>): Sequence<T>;\nexport function from<T>(object: StringKeyedObject<T>): Sequence<[string, T]>;\nexport function from<T>(object: NumberKeyedObject<T>): Sequence<[number, T]>;\nexport function from<T>(\n  iterable: Iterable<T> | StringKeyedObject<T> | NumberKeyedObject<T>\n): Sequence<T> | Sequence<[string, T]> | Sequence<[number, T]> {\n  if (iterable instanceof Sequence) {\n    return iterable;\n  } else if (_isIterable(iterable)) {\n    return new Sequence(iterable);\n  } else {\n    return new Sequence(createObjectIterable(iterable));\n  }\n}\n\nfunction _isIterable<T>(object: any): object is Iterable<T> {\n  return typeof object[Symbol.iterator] === \"function\";\n}\n"],"names":[],"mappings":"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"}