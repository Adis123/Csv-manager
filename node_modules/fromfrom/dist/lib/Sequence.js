"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const concat_1 = require("./transforms/concat");
const distinct_1 = require("./transforms/distinct");
const filter_1 = require("./transforms/filter");
const flatMap_1 = require("./transforms/flatMap");
const groupBy_1 = require("./transforms/groupBy");
const map_1 = require("./transforms/map");
const prepend_1 = require("./transforms/prepend");
const reverse_1 = require("./transforms/reverse");
const skip_1 = require("./transforms/skip");
const skipWhile_1 = require("./transforms/skipWhile");
const sortBy_1 = require("./transforms/sortBy");
const take_1 = require("./transforms/take");
const takeWhile_1 = require("./transforms/takeWhile");
const without_1 = require("./transforms/without");
const utils_1 = require("./utils");
const identityPredicateFn = (x) => x;
const defaultComparer = (a, b) => {
    if (a === b) {
        return 0;
    }
    if (a < b) {
        return -1;
    }
    return 1;
};
/**
 * A sequence of items
 */
class Sequence {
    constructor(_iterable) {
        this._iterable = _iterable;
        this[Symbol.iterator] = () => this._iterable[Symbol.iterator]();
    }
    /**
     * Returns a new sequence that contains the items in the current sequence
     * and items from the given iterable.
     *
     * @example
     * ```typescript
     * // Returns sequence with values 1, 2, 3, 4
     * from([1, 2]).concat([3, 4]);
     * ```
     */
    concat(...others) {
        return this._sequenceFromGenerator(concat_1.concat, others);
    }
    /**
     * Returns unique values in the sequence. Uniqueness is checked using
     * the '===' operator.
     *
     * @example
     * ```typescript
     * // Returns a sequence with the values 4, 5
     * from([4, 4, 5, 4]).distinct();
     * ```
     */
    distinct() {
        return this._sequenceFromGenerator(distinct_1.distinct);
    }
    /**
     * Checks that all items in the sequence pass the test implemented by the
     * provided function.
     *
     * @example
     * ```typescript
     * // Returns false
     * from([-1, 4, 5, 6]).every(x => x >= 0);
     * ```
     */
    every(predicate = identityPredicateFn) {
        for (const item of this._iterable) {
            if (!predicate(item)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Returns a new sequence where items are filtered out for which the
     * predicate function returns a falsy value.
     *
     * @example
     * ```typescript
     * // Returns a squence with the value -1
     * from([-1, 4, 5, 6]).filter(x => x < 0);
     * ```
     */
    filter(predicate) {
        return this._sequenceFromGenerator(filter_1.filter, [predicate]);
    }
    /**
     * Returns the value of the first element in the sequence that satisfies the
     * provided testing function. Otherwise undefined is returned.
     *
     * @example
     * ```typescript
     * // Returns 4
     * from([2, 4, 6]).find(x => x === 4);
     * ```
     */
    find(predicate) {
        for (const item of this._iterable) {
            if (predicate(item)) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Returns the first element of the sequence or undefined if
     * the sequence is empty.
     *
     * @example
     * ```typescript
     * // Returns 1
     * from([1, 3, 5]).first();
     * ```
     */
    first() {
        for (const item of this._iterable) {
            return item;
        }
        return undefined;
    }
    /**
     * First maps each element of the sequence using the given mapping function,
     * then flattens the result into a new sequence.
     *
     * @example
     * ```typescript
     * // Returns [1, 2, 3, 4, 5, 6]
     * from([1, 3, 5]).flatMap(x => [x, x + 1]).toArray();
     * ```
     */
    flatMap(mapperFn) {
        return this._sequenceFromGenerator(flatMap_1.flatMap, [mapperFn]);
    }
    /**
     * Calls the given callback function with each item in the sequence.
     *
     * @example
     * ```typescript
     * // Logs 1, 2 and 3 to console
     * from([1, 2, 3]).forEach(i => console.log(i));
     * ```
     */
    forEach(callback) {
        for (const item of this._iterable) {
            callback(item);
        }
    }
    groupBy(keySelector, elementSelector) {
        if (typeof keySelector === "string") {
            keySelector = createSelectByKey(keySelector);
        }
        return this._sequenceFromGenerator(groupBy_1.groupBy, [
            keySelector,
            elementSelector,
        ]);
    }
    /**
     * Determines whether the sequence includes the given element,
     * returning true or false as appropriate. The check is done
     * using '==='.
     *
     * @example
     * ```typescript
     * // Returns true
     * from([1, 2, 3]).includes(3);
     * ```
     */
    includes(searchItem) {
        for (const item of this._iterable) {
            if (item === searchItem) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns true if the sequence is empty, false otherwise.
     *
     * @example
     * ```typescript
     * // Returns true
     * from([]).isEmpty();
     * ```
     */
    isEmpty() {
        return !this.some(() => true);
    }
    /**
     * Returns the first element of the sequence or undefined if
     * the sequence is empty.
     *
     * @example
     * ```typescript
     * // Returns 5
     * from([1, 3, 5]).last();
     * ```
     */
    last() {
        const items = this.toArray();
        return items.length === 0 ? undefined : items[items.length - 1];
    }
    /**
     * Maps the sequence to a new sequence where each item is converted
     * to a new value using the given mapper function.
     *
     * @example
     * ```typescript
     * // Returns [2, 4, 6]
     * from([1, 2, 3]).map(x => x * 2);
     * ```
     */
    map(mapFn) {
        return this._sequenceFromGenerator(map_1.map, [mapFn]);
    }
    /**
     * Maps each item in the sequence to an object composed of the picked
     * object properties.
     *
     * @example
     * ```typescript
     * const users = [
     * { id: 1, name: "John", age: 31, active: true },
     * { id: 2, name: "Jane", age: 32, active: false },
     * { id: 3, name: "Luke", age: 33, active: false },
     * { id: 4, name: "Mary", age: 34, active: true },
     * ];
     *
     * // Returns a Sequence of { name: 'John' }, { name: 'Jane' }, { name: 'Luke' }, { name: 'Mary' }
     * from(users).pick("name");
     * ```
     */
    pick(...keys) {
        return this.map((item) => {
            const result = {};
            for (const key of keys) {
                if (key in item) {
                    result[key] = item[key];
                }
            }
            return result;
        });
    }
    /**
     * This method yields the elements from the provided items first, followed by the items in the
     * underlying sequence.
     *
     * @param items The provided set of items that should be in the prepended to the Sequence.
     *
     * @example
     * ```ts
     * // returns [4, 5, 6, 1, 2, 3]
     * from([1, 2, 3])
     *   .prepend([4, 5, 6])
     *   .toArray();
     * ```
     */
    prepend(...items) {
        return this._sequenceFromGenerator(prepend_1.prepend, items);
    }
    /**
     * Executes a reducer function on each item in the sequence resulting
     * in a single output value.
     *
     * @example
     * ```typescript
     * // Returns a 15
     * from([1, 2, 3, 4, 5]).reduce((x, acc) => acc+x, 0)
     * ```
     */
    reduce(callback, accumulator) {
        for (const item of this._iterable) {
            accumulator = callback(accumulator, item);
        }
        return accumulator;
    }
    /**
     * Reverses the order of the items in the sequence
     *
     * @example
     * ```typescript
     * // Returns [3, 2, 1]
     * from([1, 2, 3]).reverse().toArray();
     * ```
     */
    reverse() {
        return this._sequenceFromGenerator(reverse_1.reverse);
    }
    /**
     * Skips the first N items in the sequence
     *
     * @example
     * ```typescript
     * // Returns [3, 4]
     * from([1, 2, 3, 4]).skip(2);
     * ```
     */
    skip(howMany) {
        return this._sequenceFromGenerator(skip_1.skip, [howMany]);
    }
    /**
     * Bypasses elements in a sequence as long as a specified condition is true
     * and then returns the remaining elements.
     *
     * @param predicate  A function to test each element for a condition.
     *
     * @example
     * ```ts
     * // Returns [3, 4, 5]
     * from([1, 2, 3, 4, 5])
     *   .skipWhile(i => i < 3)
     *   .toArray();
     * ```
     */
    skipWhile(predicate) {
        return this._sequenceFromGenerator(skipWhile_1.skipWhile, [predicate]);
    }
    /**
     * Returns true if sequence contains an element for which the given
     * predicate returns a truthy value.
     *
     * @example
     * ```typescript
     * // Returns true
     * from([1, 2, 3]).some(x => x === 1)
     * ```
     */
    some(predicate = identityPredicateFn) {
        for (const item of this._iterable) {
            if (predicate(item)) {
                return true;
            }
        }
        return false;
    }
    /**
     * @example
     * ```typescript
     * const users = [
     * { id: 2, name: "Jane" },
     * { id: 4, name: "Mary" },
     * { id: 1, name: "John" },
     * { id: 3, name: "Luke" },
     * ];
     *
     * // Returns a Sequence of
     * // Returns a Sequence of
     * // { id: 4, name: 'Mary' },
     * // { id: 3, name: 'Luke' },
     * // { id: 2, name: 'Jane' },
     * // { id: 1, name: 'John' }
     * from(users).sortBy(user => user.id)
     * ```
     */
    sortBy(keySelector, comparer) {
        const compareFn = createCompareFn(false, keySelector, comparer);
        return new OrderedSequence(this._iterable, compareFn);
    }
    /**
     * Sorts the elements of a sequence in descending order according to a key
     * by using a specified comparer.
     *
     * @param keySelector  A function to extract a key from an element.
     * @param comparer     A function to compare the keys
     *
     * @example
     * ```typescript
     * // Returns a Sequence of 3, 2, 1
     * from([1, 3, 2]).sortByDescending()
     * ```
     */
    sortByDescending(keySelector, comparer) {
        const compareFn = createCompareFn(true, keySelector, comparer);
        return new OrderedSequence(this._iterable, compareFn);
    }
    sum(valueSelector) {
        let result = undefined;
        for (const item of this._iterable) {
            let itemToSum = valueSelector ? valueSelector(item) : item;
            if (result === undefined) {
                result = itemToSum;
            }
            else {
                result +=
                    typeof itemToSum === "number"
                        ? itemToSum
                        : String(itemToSum);
            }
        }
        return result === undefined ? 0 : result;
    }
    /**
     * Takes the firt N items from the sequence
     *
     * @example
     * ```typescript
     * // Returns [1, 2]
     * from([1, 2, 3, 4]).take(2);
     * ```
     */
    take(howMany) {
        return this._sequenceFromGenerator(take_1.take, [howMany]);
    }
    /**
     * Returns elements from a sequence as long as a specified condition is true,
     * and then skips the remaining elements.
     *
     * @param predicate  A function to test each element for a condition.
     *
     * @example
     * ```ts
     * // Returns [1, 2]
     * from([1, 2, 3, 4, 5])
     *   .takeWhile(i => i < 3)
     *   .toArray();
     * ```
     */
    takeWhile(predicate) {
        return this._sequenceFromGenerator(takeWhile_1.takeWhile, [predicate]);
    }
    /**
     * Returns elements from a sequence as long as they don't exist in the specified iterable items.
     *
     * @param items     The provided set of items that should not be in the returned Sequence.
     * @param predicate The optional predicate that determines if two TItem items are equal.
     *
     * @example
     * ```ts
     * // returns [2, 4, 6]
     * from([1, 2, 3, 4, 5, 6])
     *   .without([1, 3, 5])
     *   .toArray();
     *
     * // returns [{ id: 1 }, { id: 3 }]
     * from([{ id: 1 }, { id: 2 }, { id: 3 }])
     *   .without([{ id: 2 }], (a, b) => a.id === b.id)
     *   .toArray();
     * ```
     */
    without(items, predicate) {
        if (!predicate) {
            const withoutSet = new Set(items);
            return this.filter((item) => !withoutSet.has(item));
        }
        else {
            return this._sequenceFromGenerator(without_1.without, [items, predicate]);
        }
    }
    /**
     * Converts the sequence to an array
     *
     * @example
     * ```typescript
     * // Return [1, 2, 3]
     * from([1, 2, 3]).toArray();
     * ```
     */
    toArray() {
        return utils_1.copyIntoAnArray(this._iterable);
    }
    /**
     * Converts the sequence to a Map using the given keySelectorFn and
     * possible elementSelectorFn.
     *
     * @example
     * ```typescript
     * // Returns map with elements:
     * // 1 -> { id: 1, name: "John" }
     * // 2 -> { id: 2, name: "Jane"}
     * const users = [{ id: 1, name: "John" }, { id: 2, name: "Jane"}]
     * from(users).toMap(u => u.id);
     * ```
     *
     * @param keySelectorFn
     * @param elementSelectorFn
     */
    toMap(keySelectorFn, elementSelectorFn) {
        const map = new Map();
        for (const item of this._iterable) {
            const key = keySelectorFn(item);
            const value = elementSelectorFn ? elementSelectorFn(item) : item;
            map.set(key, value);
        }
        return map;
    }
    toObject(keySelectorFn, elementSelectorFn) {
        const object = {};
        for (const item of this._iterable) {
            const key = keySelectorFn(item);
            const value = elementSelectorFn ? elementSelectorFn(item) : item;
            object[key] = value;
        }
        return object;
    }
    /**
     * Converts the sequence to a Set
     *
     * @example
     * ```typescript
     * // Return a Set with elements 1, 2, 3
     * from([1, 1, 2, 3]).toSet();
     * ```
     */
    toSet() {
        return new Set(this._iterable);
    }
    _sequenceFromGenerator(factoryFn, restArgs) {
        const iterableArg = [this._iterable];
        return new Sequence(utils_1.iterableFromGenerator(factoryFn, restArgs ? iterableArg.concat(restArgs) : iterableArg));
    }
}
exports.Sequence = Sequence;
/**
 * Ordered sequence of elements
 */
class OrderedSequence extends Sequence {
    constructor(_iterableToSort, comparer) {
        super(utils_1.iterableFromGenerator(sortBy_1.sortBy, [_iterableToSort, comparer]));
        this._iterableToSort = _iterableToSort;
        this._comparer = comparer;
    }
    thenBy(keySelector, comparer) {
        const thenComparer = createCompareFn(false, keySelector, comparer);
        const compareFn = createChainedCompareFn(this._comparer, thenComparer);
        return new OrderedSequence(this._iterableToSort, compareFn);
    }
    thenByDescending(keySelector, comparer) {
        const thenComparer = createCompareFn(true, keySelector, comparer);
        const compareFn = createChainedCompareFn(this._comparer, thenComparer);
        return new OrderedSequence(this._iterableToSort, compareFn);
    }
}
exports.OrderedSequence = OrderedSequence;
/**
 * Creates a compare function that sorts TItems either ascending or descending
 * using the given key selector and comparer.
 *
 * @param descending  Sort descending or ascending
 * @param keySelector Optional function to select the key that is used for sorting
 * @param comparer    Optional comparer function to compare the keys
 */
const createCompareFn = (descending, keySelector, comparer) => {
    const compareFn = comparer || defaultComparer;
    return keySelector
        ? (a, b) => descending
            ? compareFn(keySelector(b), keySelector(a))
            : compareFn(keySelector(a), keySelector(b))
        : (a, b) => descending ? defaultComparer(b, a) : defaultComparer(a, b);
};
/**
 * Chains two compare functions. First sort by firstCompare. If items
 * are equal, then sorts by secondCompare.
 *
 * @param firstCompare
 * @param secondCompare
 */
const createChainedCompareFn = (firstCompare, secondCompare) => (a, b) => {
    const firstResult = firstCompare(a, b);
    return firstResult === 0 ? secondCompare(a, b) : firstResult;
};
const createSelectByKey = (key) => (item) => key in item ? item[key] : undefined;
//# sourceMappingURL=Sequence.js.map