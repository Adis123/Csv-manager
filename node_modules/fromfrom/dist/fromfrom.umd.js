(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = global || self, factory(global.fromfrom = {}));
}(this, function (exports) { 'use strict';

  function* concat(source, ...others) {
      yield* source;
      for (const other of others) {
          yield* other;
      }
  }

  function* distinct(iterable) {
      const unique = new Set();
      for (const item of iterable) {
          if (!unique.has(item)) {
              unique.add(item);
              yield item;
          }
      }
  }

  function* filter(iterable, predicate) {
      for (const item of iterable) {
          if (predicate(item)) {
              yield item;
          }
      }
  }

  function* flatMap(iterable, mapperFn) {
      for (const item of iterable) {
          const sequence = mapperFn(item);
          yield* sequence;
      }
  }

  function* groupBy(iterable, keySelector, elementSelector) {
      const groups = new Map();
      for (const item of iterable) {
          const key = keySelector(item);
          const value = elementSelector
              ? elementSelector(item)
              : item;
          let group = groups.get(key);
          if (!group) {
              group = [];
              groups.set(key, group);
          }
          group.push(value);
      }
      for (const keyItemsPair of groups.entries()) {
          yield {
              key: keyItemsPair[0],
              items: keyItemsPair[1],
          };
      }
  }

  function* map(source, mapFn) {
      for (const item of source) {
          yield mapFn(item);
      }
  }

  function* prepend(source, ...others) {
      for (const other of others) {
          yield* other;
      }
      yield* source;
  }

  /**
   * Copies items from the given iterable into an array
   */
  function copyIntoAnArray(iterable) {
      // Optimization for arrays, as .slice() by far fastest way to
      // create a shallow copy https://jsbench.me/pmk2aqrlo1
      if (Array.isArray(iterable)) {
          return iterable.slice();
      }
      // With iterables for-of loop is the fastest https://jsbench.me/pwk2ar61ei
      const result = [];
      for (const item of iterable) {
          result.push(item);
      }
      return result;
  }
  /**
   * Creates an iterable from given generator function
   *
   * @param generatorFn
   * @param args
   */
  const iterableFromGenerator = (generatorFn, args) => ({
      [Symbol.iterator]: () => generatorFn.apply(undefined, args),
  });

  function* reverse(iterable) {
      const items = copyIntoAnArray(iterable);
      for (let i = items.length - 1; i >= 0; i--) {
          yield items[i];
      }
  }

  function* skip(iterable, howMany) {
      let numSkipped = 0;
      for (const item of iterable) {
          if (numSkipped < howMany) {
              numSkipped++;
              continue;
          }
          yield item;
      }
  }

  function* skipWhile(iterable, predicate) {
      let startTaking = false;
      for (const item of iterable) {
          if (startTaking) {
              yield item;
          }
          else if (!predicate(item)) {
              yield item;
              startTaking = true;
          }
      }
  }

  function* sortBy(iterable, comparer) {
      yield* copyIntoAnArray(iterable).sort(comparer);
  }

  function* take(iterable, howMany) {
      if (howMany < 1) {
          return;
      }
      let numTaken = 0;
      for (const item of iterable) {
          numTaken++;
          yield item;
          if (numTaken >= howMany) {
              break;
          }
      }
  }

  function* takeWhile(iterable, predicate) {
      for (const item of iterable) {
          if (!predicate(item)) {
              break;
          }
          yield item;
      }
  }

  function* without(iterator, withoutItems, comparePredicate) {
      // cache already found results
      const cache = new Set();
      outer: for (const item of iterator) {
          // fast path, this item was already found, don't loop
          if (cache.has(item))
              continue;
          // slow path, loop over each item in the set, determine if it matches the ComparePredicate
          for (const withoutItem of withoutItems) {
              // if the item is found, add it to the cache and skip the item
              if (comparePredicate(item, withoutItem)) {
                  cache.add(item);
                  continue outer;
              }
          }
          // we can safely yield the item
          yield item;
      }
  }

  const identityPredicateFn = (x) => x;
  const defaultComparer = (a, b) => {
      if (a === b) {
          return 0;
      }
      if (a < b) {
          return -1;
      }
      return 1;
  };
  /**
   * A sequence of items
   */
  class Sequence {
      constructor(_iterable) {
          this._iterable = _iterable;
          this[Symbol.iterator] = () => this._iterable[Symbol.iterator]();
      }
      /**
       * Returns a new sequence that contains the items in the current sequence
       * and items from the given iterable.
       *
       * @example
       * ```typescript
       * // Returns sequence with values 1, 2, 3, 4
       * from([1, 2]).concat([3, 4]);
       * ```
       */
      concat(...others) {
          return this._sequenceFromGenerator(concat, others);
      }
      /**
       * Returns unique values in the sequence. Uniqueness is checked using
       * the '===' operator.
       *
       * @example
       * ```typescript
       * // Returns a sequence with the values 4, 5
       * from([4, 4, 5, 4]).distinct();
       * ```
       */
      distinct() {
          return this._sequenceFromGenerator(distinct);
      }
      /**
       * Checks that all items in the sequence pass the test implemented by the
       * provided function.
       *
       * @example
       * ```typescript
       * // Returns false
       * from([-1, 4, 5, 6]).every(x => x >= 0);
       * ```
       */
      every(predicate = identityPredicateFn) {
          for (const item of this._iterable) {
              if (!predicate(item)) {
                  return false;
              }
          }
          return true;
      }
      /**
       * Returns a new sequence where items are filtered out for which the
       * predicate function returns a falsy value.
       *
       * @example
       * ```typescript
       * // Returns a squence with the value -1
       * from([-1, 4, 5, 6]).filter(x => x < 0);
       * ```
       */
      filter(predicate) {
          return this._sequenceFromGenerator(filter, [predicate]);
      }
      /**
       * Returns the value of the first element in the sequence that satisfies the
       * provided testing function. Otherwise undefined is returned.
       *
       * @example
       * ```typescript
       * // Returns 4
       * from([2, 4, 6]).find(x => x === 4);
       * ```
       */
      find(predicate) {
          for (const item of this._iterable) {
              if (predicate(item)) {
                  return item;
              }
          }
          return undefined;
      }
      /**
       * Returns the first element of the sequence or undefined if
       * the sequence is empty.
       *
       * @example
       * ```typescript
       * // Returns 1
       * from([1, 3, 5]).first();
       * ```
       */
      first() {
          for (const item of this._iterable) {
              return item;
          }
          return undefined;
      }
      /**
       * First maps each element of the sequence using the given mapping function,
       * then flattens the result into a new sequence.
       *
       * @example
       * ```typescript
       * // Returns [1, 2, 3, 4, 5, 6]
       * from([1, 3, 5]).flatMap(x => [x, x + 1]).toArray();
       * ```
       */
      flatMap(mapperFn) {
          return this._sequenceFromGenerator(flatMap, [mapperFn]);
      }
      /**
       * Calls the given callback function with each item in the sequence.
       *
       * @example
       * ```typescript
       * // Logs 1, 2 and 3 to console
       * from([1, 2, 3]).forEach(i => console.log(i));
       * ```
       */
      forEach(callback) {
          for (const item of this._iterable) {
              callback(item);
          }
      }
      groupBy(keySelector, elementSelector) {
          if (typeof keySelector === "string") {
              keySelector = createSelectByKey(keySelector);
          }
          return this._sequenceFromGenerator(groupBy, [
              keySelector,
              elementSelector,
          ]);
      }
      /**
       * Determines whether the sequence includes the given element,
       * returning true or false as appropriate. The check is done
       * using '==='.
       *
       * @example
       * ```typescript
       * // Returns true
       * from([1, 2, 3]).includes(3);
       * ```
       */
      includes(searchItem) {
          for (const item of this._iterable) {
              if (item === searchItem) {
                  return true;
              }
          }
          return false;
      }
      /**
       * Returns true if the sequence is empty, false otherwise.
       *
       * @example
       * ```typescript
       * // Returns true
       * from([]).isEmpty();
       * ```
       */
      isEmpty() {
          return !this.some(() => true);
      }
      /**
       * Returns the first element of the sequence or undefined if
       * the sequence is empty.
       *
       * @example
       * ```typescript
       * // Returns 5
       * from([1, 3, 5]).last();
       * ```
       */
      last() {
          const items = this.toArray();
          return items.length === 0 ? undefined : items[items.length - 1];
      }
      /**
       * Maps the sequence to a new sequence where each item is converted
       * to a new value using the given mapper function.
       *
       * @example
       * ```typescript
       * // Returns [2, 4, 6]
       * from([1, 2, 3]).map(x => x * 2);
       * ```
       */
      map(mapFn) {
          return this._sequenceFromGenerator(map, [mapFn]);
      }
      /**
       * Maps each item in the sequence to an object composed of the picked
       * object properties.
       *
       * @example
       * ```typescript
       * const users = [
       * { id: 1, name: "John", age: 31, active: true },
       * { id: 2, name: "Jane", age: 32, active: false },
       * { id: 3, name: "Luke", age: 33, active: false },
       * { id: 4, name: "Mary", age: 34, active: true },
       * ];
       *
       * // Returns a Sequence of { name: 'John' }, { name: 'Jane' }, { name: 'Luke' }, { name: 'Mary' }
       * from(users).pick("name");
       * ```
       */
      pick(...keys) {
          return this.map((item) => {
              const result = {};
              for (const key of keys) {
                  if (key in item) {
                      result[key] = item[key];
                  }
              }
              return result;
          });
      }
      /**
       * This method yields the elements from the provided items first, followed by the items in the
       * underlying sequence.
       *
       * @param items The provided set of items that should be in the prepended to the Sequence.
       *
       * @example
       * ```ts
       * // returns [4, 5, 6, 1, 2, 3]
       * from([1, 2, 3])
       *   .prepend([4, 5, 6])
       *   .toArray();
       * ```
       */
      prepend(...items) {
          return this._sequenceFromGenerator(prepend, items);
      }
      /**
       * Executes a reducer function on each item in the sequence resulting
       * in a single output value.
       *
       * @example
       * ```typescript
       * // Returns a 15
       * from([1, 2, 3, 4, 5]).reduce((x, acc) => acc+x, 0)
       * ```
       */
      reduce(callback, accumulator) {
          for (const item of this._iterable) {
              accumulator = callback(accumulator, item);
          }
          return accumulator;
      }
      /**
       * Reverses the order of the items in the sequence
       *
       * @example
       * ```typescript
       * // Returns [3, 2, 1]
       * from([1, 2, 3]).reverse().toArray();
       * ```
       */
      reverse() {
          return this._sequenceFromGenerator(reverse);
      }
      /**
       * Skips the first N items in the sequence
       *
       * @example
       * ```typescript
       * // Returns [3, 4]
       * from([1, 2, 3, 4]).skip(2);
       * ```
       */
      skip(howMany) {
          return this._sequenceFromGenerator(skip, [howMany]);
      }
      /**
       * Bypasses elements in a sequence as long as a specified condition is true
       * and then returns the remaining elements.
       *
       * @param predicate  A function to test each element for a condition.
       *
       * @example
       * ```ts
       * // Returns [3, 4, 5]
       * from([1, 2, 3, 4, 5])
       *   .skipWhile(i => i < 3)
       *   .toArray();
       * ```
       */
      skipWhile(predicate) {
          return this._sequenceFromGenerator(skipWhile, [predicate]);
      }
      /**
       * Returns true if sequence contains an element for which the given
       * predicate returns a truthy value.
       *
       * @example
       * ```typescript
       * // Returns true
       * from([1, 2, 3]).some(x => x === 1)
       * ```
       */
      some(predicate = identityPredicateFn) {
          for (const item of this._iterable) {
              if (predicate(item)) {
                  return true;
              }
          }
          return false;
      }
      /**
       * @example
       * ```typescript
       * const users = [
       * { id: 2, name: "Jane" },
       * { id: 4, name: "Mary" },
       * { id: 1, name: "John" },
       * { id: 3, name: "Luke" },
       * ];
       *
       * // Returns a Sequence of
       * // Returns a Sequence of
       * // { id: 4, name: 'Mary' },
       * // { id: 3, name: 'Luke' },
       * // { id: 2, name: 'Jane' },
       * // { id: 1, name: 'John' }
       * from(users).sortBy(user => user.id)
       * ```
       */
      sortBy(keySelector, comparer) {
          const compareFn = createCompareFn(false, keySelector, comparer);
          return new OrderedSequence(this._iterable, compareFn);
      }
      /**
       * Sorts the elements of a sequence in descending order according to a key
       * by using a specified comparer.
       *
       * @param keySelector  A function to extract a key from an element.
       * @param comparer     A function to compare the keys
       *
       * @example
       * ```typescript
       * // Returns a Sequence of 3, 2, 1
       * from([1, 3, 2]).sortByDescending()
       * ```
       */
      sortByDescending(keySelector, comparer) {
          const compareFn = createCompareFn(true, keySelector, comparer);
          return new OrderedSequence(this._iterable, compareFn);
      }
      sum(valueSelector) {
          let result = undefined;
          for (const item of this._iterable) {
              let itemToSum = valueSelector ? valueSelector(item) : item;
              if (result === undefined) {
                  result = itemToSum;
              }
              else {
                  result +=
                      typeof itemToSum === "number"
                          ? itemToSum
                          : String(itemToSum);
              }
          }
          return result === undefined ? 0 : result;
      }
      /**
       * Takes the firt N items from the sequence
       *
       * @example
       * ```typescript
       * // Returns [1, 2]
       * from([1, 2, 3, 4]).take(2);
       * ```
       */
      take(howMany) {
          return this._sequenceFromGenerator(take, [howMany]);
      }
      /**
       * Returns elements from a sequence as long as a specified condition is true,
       * and then skips the remaining elements.
       *
       * @param predicate  A function to test each element for a condition.
       *
       * @example
       * ```ts
       * // Returns [1, 2]
       * from([1, 2, 3, 4, 5])
       *   .takeWhile(i => i < 3)
       *   .toArray();
       * ```
       */
      takeWhile(predicate) {
          return this._sequenceFromGenerator(takeWhile, [predicate]);
      }
      /**
       * Returns elements from a sequence as long as they don't exist in the specified iterable items.
       *
       * @param items     The provided set of items that should not be in the returned Sequence.
       * @param predicate The optional predicate that determines if two TItem items are equal.
       *
       * @example
       * ```ts
       * // returns [2, 4, 6]
       * from([1, 2, 3, 4, 5, 6])
       *   .without([1, 3, 5])
       *   .toArray();
       *
       * // returns [{ id: 1 }, { id: 3 }]
       * from([{ id: 1 }, { id: 2 }, { id: 3 }])
       *   .without([{ id: 2 }], (a, b) => a.id === b.id)
       *   .toArray();
       * ```
       */
      without(items, predicate) {
          if (!predicate) {
              const withoutSet = new Set(items);
              return this.filter((item) => !withoutSet.has(item));
          }
          else {
              return this._sequenceFromGenerator(without, [items, predicate]);
          }
      }
      /**
       * Converts the sequence to an array
       *
       * @example
       * ```typescript
       * // Return [1, 2, 3]
       * from([1, 2, 3]).toArray();
       * ```
       */
      toArray() {
          return copyIntoAnArray(this._iterable);
      }
      /**
       * Converts the sequence to a Map using the given keySelectorFn and
       * possible elementSelectorFn.
       *
       * @example
       * ```typescript
       * // Returns map with elements:
       * // 1 -> { id: 1, name: "John" }
       * // 2 -> { id: 2, name: "Jane"}
       * const users = [{ id: 1, name: "John" }, { id: 2, name: "Jane"}]
       * from(users).toMap(u => u.id);
       * ```
       *
       * @param keySelectorFn
       * @param elementSelectorFn
       */
      toMap(keySelectorFn, elementSelectorFn) {
          const map = new Map();
          for (const item of this._iterable) {
              const key = keySelectorFn(item);
              const value = elementSelectorFn ? elementSelectorFn(item) : item;
              map.set(key, value);
          }
          return map;
      }
      toObject(keySelectorFn, elementSelectorFn) {
          const object = {};
          for (const item of this._iterable) {
              const key = keySelectorFn(item);
              const value = elementSelectorFn ? elementSelectorFn(item) : item;
              object[key] = value;
          }
          return object;
      }
      /**
       * Converts the sequence to a Set
       *
       * @example
       * ```typescript
       * // Return a Set with elements 1, 2, 3
       * from([1, 1, 2, 3]).toSet();
       * ```
       */
      toSet() {
          return new Set(this._iterable);
      }
      _sequenceFromGenerator(factoryFn, restArgs) {
          const iterableArg = [this._iterable];
          return new Sequence(iterableFromGenerator(factoryFn, restArgs ? iterableArg.concat(restArgs) : iterableArg));
      }
  }
  /**
   * Ordered sequence of elements
   */
  class OrderedSequence extends Sequence {
      constructor(_iterableToSort, comparer) {
          super(iterableFromGenerator(sortBy, [_iterableToSort, comparer]));
          this._iterableToSort = _iterableToSort;
          this._comparer = comparer;
      }
      thenBy(keySelector, comparer) {
          const thenComparer = createCompareFn(false, keySelector, comparer);
          const compareFn = createChainedCompareFn(this._comparer, thenComparer);
          return new OrderedSequence(this._iterableToSort, compareFn);
      }
      thenByDescending(keySelector, comparer) {
          const thenComparer = createCompareFn(true, keySelector, comparer);
          const compareFn = createChainedCompareFn(this._comparer, thenComparer);
          return new OrderedSequence(this._iterableToSort, compareFn);
      }
  }
  /**
   * Creates a compare function that sorts TItems either ascending or descending
   * using the given key selector and comparer.
   *
   * @param descending  Sort descending or ascending
   * @param keySelector Optional function to select the key that is used for sorting
   * @param comparer    Optional comparer function to compare the keys
   */
  const createCompareFn = (descending, keySelector, comparer) => {
      const compareFn = comparer || defaultComparer;
      return keySelector
          ? (a, b) => descending
              ? compareFn(keySelector(b), keySelector(a))
              : compareFn(keySelector(a), keySelector(b))
          : (a, b) => descending ? defaultComparer(b, a) : defaultComparer(a, b);
  };
  /**
   * Chains two compare functions. First sort by firstCompare. If items
   * are equal, then sorts by secondCompare.
   *
   * @param firstCompare
   * @param secondCompare
   */
  const createChainedCompareFn = (firstCompare, secondCompare) => (a, b) => {
      const firstResult = firstCompare(a, b);
      return firstResult === 0 ? secondCompare(a, b) : firstResult;
  };
  const createSelectByKey = (key) => (item) => key in item ? item[key] : undefined;

  function createObjectIterable(object) {
      return iterableFromGenerator(objectIterator, [object]);
  }
  function* objectIterator(object) {
      for (const key in object) {
          if (object.hasOwnProperty(key)) {
              const value = object[key];
              yield [key, value];
          }
      }
  }

  /**
   * Entrypoint of the library
   */
  function from(iterable) {
      if (iterable instanceof Sequence) {
          return iterable;
      }
      else if (_isIterable(iterable)) {
          return new Sequence(iterable);
      }
      else {
          return new Sequence(createObjectIterable(iterable));
      }
  }
  function _isIterable(object) {
      return typeof object[Symbol.iterator] === "function";
  }

  exports.from = from;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=fromfrom.umd.js.map
