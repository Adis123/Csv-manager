{"version":3,"file":"fromfrom.umd.min.js","sources":["../src/transforms/concat.ts","../src/transforms/distinct.ts","../src/transforms/filter.ts","../src/transforms/flatMap.ts","../src/transforms/groupBy.ts","../src/transforms/map.ts","../src/transforms/prepend.ts","../src/utils.ts","../src/transforms/reverse.ts","../src/transforms/skip.ts","../src/transforms/skipWhile.ts","../src/transforms/sortBy.ts","../src/transforms/take.ts","../src/transforms/takeWhile.ts","../src/transforms/without.ts","../src/Sequence.ts","../src/ObjectIterable.ts","../src/fromfrom.ts"],"sourcesContent":["export function* concat<TItem, TOther>(\n  source: Iterable<TItem>,\n  ...others: Iterable<TOther>[]\n) {\n  yield* source;\n  for (const other of others) {\n    yield* other;\n  }\n}\n","export function* distinct<TItem>(iterable: Iterable<TItem>) {\n  const unique = new Set();\n\n  for (const item of iterable) {\n    if (!unique.has(item)) {\n      unique.add(item);\n      yield item;\n    }\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* filter<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  for (const item of iterable) {\n    if (predicate(item)) {\n      yield item;\n    }\n  }\n}\n","import { MapFn } from \"../types\";\n\nexport function* flatMap<TItem, TOther>(\n  iterable: Iterable<TItem>,\n  mapperFn: MapFn<TItem, TOther[]>\n) {\n  for (const item of iterable) {\n    const sequence = mapperFn(item);\n    yield* sequence;\n  }\n}\n","import { KeySelectorFn, MapFn, Grouping } from \"../types\";\n\nexport function* groupBy<TItem, TKey, TElement>(\n  iterable: Iterable<TItem>,\n  keySelector: KeySelectorFn<TItem, TKey>,\n  elementSelector?: MapFn<TItem, TElement>\n): IterableIterator<Grouping<TKey, TElement>> {\n  const groups = new Map<TKey, TElement[]>();\n\n  for (const item of iterable) {\n    const key = keySelector(item);\n    const value = elementSelector\n      ? elementSelector(item)\n      : ((item as unknown) as TElement);\n\n    let group = groups.get(key);\n    if (!group) {\n      group = [];\n      groups.set(key, group);\n    }\n\n    group.push(value);\n  }\n\n  for (const keyItemsPair of groups.entries()) {\n    yield {\n      key: keyItemsPair[0],\n      items: keyItemsPair[1],\n    };\n  }\n}\n","import { MapFn } from \"../types\";\n\nexport function* map<TItem, TResult>(\n  source: Iterable<TItem>,\n  mapFn: MapFn<TItem, TResult>\n) {\n  for (const item of source) {\n    yield mapFn(item);\n  }\n}\n","export function* prepend<TItem, TOther>(\n  source: Iterable<TItem>,\n  ...others: Iterable<TOther>[]\n) {\n  for (const other of others) {\n    yield* other;\n  }\n  yield* source;\n}\n","/**\n * Copies items from the given iterable into an array\n */\nexport function copyIntoAnArray<T>(iterable: Iterable<T>) {\n  // Optimization for arrays, as .slice() by far fastest way to\n  // create a shallow copy https://jsbench.me/pmk2aqrlo1\n  if (Array.isArray(iterable)) {\n    return iterable.slice();\n  }\n\n  // With iterables for-of loop is the fastest https://jsbench.me/pwk2ar61ei\n  const result = [];\n  for (const item of iterable) {\n    result.push(item);\n  }\n\n  return result;\n}\n\n/**\n * Creates an iterable from given generator function\n *\n * @param generatorFn\n * @param args\n */\nexport const iterableFromGenerator = <TItem>(\n  generatorFn: Function,\n  args?: any[]\n): Iterable<TItem> => ({\n  [Symbol.iterator]: (): Iterator<TItem> => generatorFn.apply(undefined, args),\n});\n","import { copyIntoAnArray } from \"../utils\";\n\nexport function* reverse<TItem>(iterable: Iterable<TItem>) {\n  const items = copyIntoAnArray(iterable);\n\n  for (let i = items.length - 1; i >= 0; i--) {\n    yield items[i];\n  }\n}\n","export function* skip<TItem>(iterable: Iterable<TItem>, howMany: number) {\n  let numSkipped = 0;\n\n  for (const item of iterable) {\n    if (numSkipped < howMany) {\n      numSkipped++;\n      continue;\n    }\n\n    yield item;\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* skipWhile<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  let startTaking = false;\n\n  for (const item of iterable) {\n    if (startTaking) {\n      yield item;\n    } else if (!predicate(item)) {\n      yield item;\n      startTaking = true;\n    }\n  }\n}\n","import { ComparerFn } from \"../types\";\nimport { copyIntoAnArray } from \"../utils\";\n\nexport function* sortBy<TItem>(\n  iterable: Iterable<TItem>,\n  comparer: ComparerFn<TItem>\n) {\n  yield* copyIntoAnArray(iterable).sort(comparer);\n}\n","export function* take<TItem>(iterable: Iterable<TItem>, howMany: number) {\n  if (howMany < 1) {\n    return;\n  }\n\n  let numTaken = 0;\n\n  for (const item of iterable) {\n    numTaken++;\n    yield item;\n\n    if (numTaken >= howMany) {\n      break;\n    }\n  }\n}\n","import { PredicateFn } from \"../types\";\n\nexport function* takeWhile<TItem>(\n  iterable: Iterable<TItem>,\n  predicate: PredicateFn<TItem>\n) {\n  for (const item of iterable) {\n    if (!predicate(item)) {\n      break;\n    }\n\n    yield item;\n  }\n}\n","import { ComparePredicate } from \"../types\";\n\nexport function* without<TItem>(\n  iterator: Iterable<TItem>,\n  withoutItems: Iterable<TItem>,\n  comparePredicate: ComparePredicate<TItem>\n) {\n  // cache already found results\n  const cache = new Set();\n\n  outer: for (const item of iterator) {\n    // fast path, this item was already found, don't loop\n    if (cache.has(item)) continue;\n    // slow path, loop over each item in the set, determine if it matches the ComparePredicate\n    for (const withoutItem of withoutItems) {\n      // if the item is found, add it to the cache and skip the item\n      if (comparePredicate(item, withoutItem)) {\n        cache.add(item);\n        continue outer;\n      }\n    }\n\n    // we can safely yield the item\n    yield item;\n  }\n}\n","import {\n  KeySelectorFn,\n  ComparerFn,\n  PredicateFn,\n  MapFn,\n  CallbackFn,\n  Grouping,\n  ReduceCallbackFn,\n  NumberKeyedObject,\n  StringKeyedObject,\n  ComparePredicate,\n} from \"./types\";\nimport { concat } from \"./transforms/concat\";\nimport { distinct } from \"./transforms/distinct\";\nimport { filter } from \"./transforms/filter\";\nimport { flatMap } from \"./transforms/flatMap\";\nimport { groupBy } from \"./transforms/groupBy\";\nimport { map } from \"./transforms/map\";\nimport { prepend } from \"./transforms/prepend\";\nimport { reverse } from \"./transforms/reverse\";\nimport { skip } from \"./transforms/skip\";\nimport { skipWhile } from \"./transforms/skipWhile\";\nimport { sortBy } from \"./transforms/sortBy\";\nimport { take } from \"./transforms/take\";\nimport { takeWhile } from \"./transforms/takeWhile\";\nimport { without } from \"./transforms/without\";\nimport { copyIntoAnArray, iterableFromGenerator } from \"./utils\";\n\nconst identityPredicateFn = (x: any): boolean => x;\n\nconst defaultComparer = <TKey>(a: TKey, b: TKey) => {\n  if (a === b) {\n    return 0;\n  }\n\n  if (a < b) {\n    return -1;\n  }\n\n  return 1;\n};\n\n/**\n * A sequence of items\n */\nexport class Sequence<TItem> implements Iterable<TItem> {\n  constructor(protected _iterable: Iterable<TItem>) {}\n\n  [Symbol.iterator] = (): Iterator<TItem> => this._iterable[Symbol.iterator]();\n\n  /**\n   * Returns a new sequence that contains the items in the current sequence\n   * and items from the given iterable.\n   *\n   * @example\n   * ```typescript\n   * // Returns sequence with values 1, 2, 3, 4\n   * from([1, 2]).concat([3, 4]);\n   * ```\n   */\n  concat<TOther>(...others: Iterable<TOther>[]): Sequence<TItem | TOther> {\n    return this._sequenceFromGenerator<TItem | TOther>(concat, others);\n  }\n\n  /**\n   * Returns unique values in the sequence. Uniqueness is checked using\n   * the '===' operator.\n   *\n   * @example\n   * ```typescript\n   * // Returns a sequence with the values 4, 5\n   * from([4, 4, 5, 4]).distinct();\n   * ```\n   */\n  distinct(): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(distinct);\n  }\n\n  /**\n   * Checks that all items in the sequence pass the test implemented by the\n   * provided function.\n   *\n   * @example\n   * ```typescript\n   * // Returns false\n   * from([-1, 4, 5, 6]).every(x => x >= 0);\n   * ```\n   */\n  every(predicate: PredicateFn<TItem> = identityPredicateFn): boolean {\n    for (const item of this._iterable) {\n      if (!predicate(item)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns a new sequence where items are filtered out for which the\n   * predicate function returns a falsy value.\n   *\n   * @example\n   * ```typescript\n   * // Returns a squence with the value -1\n   * from([-1, 4, 5, 6]).filter(x => x < 0);\n   * ```\n   */\n  filter(predicate: PredicateFn<TItem>): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(filter, [predicate]);\n  }\n\n  /**\n   * Returns the value of the first element in the sequence that satisfies the\n   * provided testing function. Otherwise undefined is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns 4\n   * from([2, 4, 6]).find(x => x === 4);\n   * ```\n   */\n  find(predicate: PredicateFn<TItem>): TItem | undefined {\n    for (const item of this._iterable) {\n      if (predicate(item)) {\n        return item;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Returns the first element of the sequence or undefined if\n   * the sequence is empty.\n   *\n   * @example\n   * ```typescript\n   * // Returns 1\n   * from([1, 3, 5]).first();\n   * ```\n   */\n  first(): TItem | undefined {\n    for (const item of this._iterable) {\n      return item;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * First maps each element of the sequence using the given mapping function,\n   * then flattens the result into a new sequence.\n   *\n   * @example\n   * ```typescript\n   * // Returns [1, 2, 3, 4, 5, 6]\n   * from([1, 3, 5]).flatMap(x => [x, x + 1]).toArray();\n   * ```\n   */\n  flatMap<TResultItem>(\n    mapperFn: MapFn<TItem, TResultItem[]>\n  ): Sequence<TResultItem> {\n    return this._sequenceFromGenerator<TResultItem>(flatMap, [mapperFn]);\n  }\n\n  /**\n   * Calls the given callback function with each item in the sequence.\n   *\n   * @example\n   * ```typescript\n   * // Logs 1, 2 and 3 to console\n   * from([1, 2, 3]).forEach(i => console.log(i));\n   * ```\n   */\n  forEach(callback: CallbackFn<TItem>): void {\n    for (const item of this._iterable) {\n      callback(item);\n    }\n  }\n\n  /**\n   * Groups the items in the sequence using the given item's key\n   *\n   * @param key Key to be used for the grouping\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\");\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\n   * //     { name: \"John\", gender: \"M\" },\n   * //     { name: \"Mike\", gender: \"M\" }\n   * //   ]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\n   * //     { name: \"Lisa\", gender: \"F\" },\n   * //     { name: \"Mary\", gender: \"F\" }\n   * //   ]\n   * // }\n   * ```\n   */\n  groupBy<TKey extends keyof TItem>(\n    key: TKey\n  ): Sequence<Grouping<TItem[TKey], TItem>>;\n  /**\n   * Groups the items in the sequence by keys returned by the given\n   * keySelector function.\n   *\n   * @param keySelector A function to extract the key for each element.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(user => user.gender);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\n   * //     { name: \"John\", gender: \"M\" },\n   * //     { name: \"Mike\", gender: \"M\" }\n   * //   ]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\n   * //     { name: \"Lisa\", gender: \"F\" },\n   * //     { name: \"Mary\", gender: \"F\" }\n   * //   ]\n   * // }\n   * ```\n   */\n  groupBy<TKey>(\n    keySelector: KeySelectorFn<TItem, TKey>\n  ): Sequence<Grouping<TKey, TItem>>;\n  /**\n   * Groups the items of a sequence according to a specified key and\n   * projects the elements for each group by using a specified function.\n   *\n   * @param key Key to be used for the grouping\n   * @param elementSelector A function to map each source element to an element in an Grouping<TKey,TElement>.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\", user => user.name);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\"John\", \"Mike\"]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\"Lisa\", \"Mary\"]\n   * // }\n   * ```\n   */\n  groupBy<TKey extends keyof TItem, TElement>(\n    key: TKey,\n    elementSelector: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TItem[TKey], TItem>>;\n  /**\n   * Groups the elements of a sequence according to a specified key selector\n   * function and projects the elements for each group by using a specified\n   * function.\n   *\n   * @param keySelector A function to extract the key for each element.\n   * @param elementSelector A function to map each source element to an element in an Grouping<TKey,TElement>.\n   *\n   * @example\n   * ```typescript\n   * from([\n   *   { name: \"John\", gender: \"M\" },\n   *   { name: \"Mike\", gender: \"M\" },\n   *   { name: \"Lisa\", gender: \"F\" },\n   *   { name: \"Mary\", gender: \"F\" }\n   * ]).groupBy(\"gender\", user => user.name);\n   * // Returns a sequence with two groupings:\n   * // {\n   * //   key: \"M\",\n   * //   items: [\"John\", \"Mike\"]\n   * // },\n   * // {\n   * //   key: \"F\",\n   * //   items: [\"Lisa\", \"Mary\"]\n   * // }\n   * ```\n   */\n  groupBy<TKey, TElement>(\n    keySelector: KeySelectorFn<TItem, TKey>,\n    elementSelector: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TKey, TElement>>;\n  groupBy<TKey, TElement>(\n    keySelector: KeySelectorFn<TItem, TKey> | string,\n    elementSelector?: MapFn<TItem, TElement>\n  ): Sequence<Grouping<TKey, TElement>> {\n    if (typeof keySelector === \"string\") {\n      keySelector = createSelectByKey<TItem>(keySelector);\n    }\n\n    return this._sequenceFromGenerator<Grouping<TKey, TElement>>(groupBy, [\n      keySelector,\n      elementSelector,\n    ]);\n  }\n\n  /**\n   * Determines whether the sequence includes the given element,\n   * returning true or false as appropriate. The check is done\n   * using '==='.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([1, 2, 3]).includes(3);\n   * ```\n   */\n  includes(searchItem: TItem): boolean {\n    for (const item of this._iterable) {\n      if (item === searchItem) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if the sequence is empty, false otherwise.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([]).isEmpty();\n   * ```\n   */\n  isEmpty(): boolean {\n    return !this.some(() => true);\n  }\n\n  /**\n   * Returns the first element of the sequence or undefined if\n   * the sequence is empty.\n   *\n   * @example\n   * ```typescript\n   * // Returns 5\n   * from([1, 3, 5]).last();\n   * ```\n   */\n  last(): TItem | undefined {\n    const items = this.toArray();\n\n    return items.length === 0 ? undefined : items[items.length - 1];\n  }\n\n  /**\n   * Maps the sequence to a new sequence where each item is converted\n   * to a new value using the given mapper function.\n   *\n   * @example\n   * ```typescript\n   * // Returns [2, 4, 6]\n   * from([1, 2, 3]).map(x => x * 2);\n   * ```\n   */\n  map<TResultItem>(mapFn: MapFn<TItem, TResultItem>): Sequence<TResultItem> {\n    return this._sequenceFromGenerator<TResultItem>(map, [mapFn]);\n  }\n\n  /**\n   * Maps each item in the sequence to an object composed of the picked\n   * object properties.\n   *\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 1, name: \"John\", age: 31, active: true },\n   * { id: 2, name: \"Jane\", age: 32, active: false },\n   * { id: 3, name: \"Luke\", age: 33, active: false },\n   * { id: 4, name: \"Mary\", age: 34, active: true },\n   * ];\n   *\n   * // Returns a Sequence of { name: 'John' }, { name: 'Jane' }, { name: 'Luke' }, { name: 'Mary' }\n   * from(users).pick(\"name\");\n   * ```\n   */\n  pick<TKeys extends keyof TItem>(\n    ...keys: TKeys[]\n  ): Sequence<{ [P in TKeys]: TItem[P] }> {\n    return this.map((item: TItem) => {\n      const result: any = {};\n\n      for (const key of keys) {\n        if (key in item) {\n          result[key] = item[key];\n        }\n      }\n\n      return result;\n    });\n  }\n\n  /**\n   * This method yields the elements from the provided items first, followed by the items in the\n   * underlying sequence.\n   *\n   * @param items The provided set of items that should be in the prepended to the Sequence.\n   *\n   * @example\n   * ```ts\n   * // returns [4, 5, 6, 1, 2, 3]\n   * from([1, 2, 3])\n   *   .prepend([4, 5, 6])\n   *   .toArray();\n   * ```\n   */\n  prepend(...items: Iterable<TItem>[]): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(prepend, items);\n  }\n\n  /**\n   * Executes a reducer function on each item in the sequence resulting\n   * in a single output value.\n   *\n   * @example\n   * ```typescript\n   * // Returns a 15\n   * from([1, 2, 3, 4, 5]).reduce((x, acc) => acc+x, 0)\n   * ```\n   */\n  reduce<TResult>(\n    callback: ReduceCallbackFn<TResult, TItem>,\n    accumulator: TResult\n  ): TResult {\n    for (const item of this._iterable) {\n      accumulator = callback(accumulator, item);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Reverses the order of the items in the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [3, 2, 1]\n   * from([1, 2, 3]).reverse().toArray();\n   * ```\n   */\n  reverse(): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(reverse);\n  }\n\n  /**\n   * Skips the first N items in the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [3, 4]\n   * from([1, 2, 3, 4]).skip(2);\n   * ```\n   */\n  skip(howMany: number): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(skip, [howMany]);\n  }\n\n  /**\n   * Bypasses elements in a sequence as long as a specified condition is true\n   * and then returns the remaining elements.\n   *\n   * @param predicate  A function to test each element for a condition.\n   *\n   * @example\n   * ```ts\n   * // Returns [3, 4, 5]\n   * from([1, 2, 3, 4, 5])\n   *   .skipWhile(i => i < 3)\n   *   .toArray();\n   * ```\n   */\n  skipWhile(predicate: PredicateFn<TItem>): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(skipWhile, [predicate]);\n  }\n\n  /**\n   * Returns true if sequence contains an element for which the given\n   * predicate returns a truthy value.\n   *\n   * @example\n   * ```typescript\n   * // Returns true\n   * from([1, 2, 3]).some(x => x === 1)\n   * ```\n   */\n  some(predicate: PredicateFn<TItem> = identityPredicateFn): boolean {\n    for (const item of this._iterable) {\n      if (predicate(item)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Sorts the elements of a sequence in ascending order according to a key\n   * by using a specified comparer.\n   *\n   * @param keySelector  A function to extract a key from an element.\n   * @param comparer     A function to compare the keys\n   */\n  /**\n   * @example\n   * ```typescript\n   * // Returns a Sequence of 1, 2, 3\n   * from([1, 3, 2]).sortBy()\n   * ```\n   */\n  sortBy(): OrderedSequence<TItem>;\n  /**\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 2, name: \"Jane\" },\n   * { id: 4, name: \"Mary\" },\n   * { id: 1, name: \"John\" },\n   * { id: 3, name: \"Luke\" },\n   * ];\n   *\n   * // Returns a Sequence of\n   * //  { id: 1, name: 'John' },\n   * //  { id: 2, name: 'Jane' },\n   * //  { id: 3, name: 'Luke' },\n   * //  { id: 4, name: 'Mary' }\n   * from(users).sortBy(user => user.id)\n   * ```\n   */\n  sortBy<TKey>(\n    keySelector: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem>;\n  /**\n   * @example\n   * ```typescript\n   * const users = [\n   * { id: 2, name: \"Jane\" },\n   * { id: 4, name: \"Mary\" },\n   * { id: 1, name: \"John\" },\n   * { id: 3, name: \"Luke\" },\n   * ];\n   *\n   * // Returns a Sequence of\n   * // Returns a Sequence of\n   * // { id: 4, name: 'Mary' },\n   * // { id: 3, name: 'Luke' },\n   * // { id: 2, name: 'Jane' },\n   * // { id: 1, name: 'John' }\n   * from(users).sortBy(user => user.id)\n   * ```\n   */\n  sortBy<TKey>(\n    keySelector?: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem> {\n    const compareFn = createCompareFn(false, keySelector, comparer);\n\n    return new OrderedSequence(this._iterable, compareFn);\n  }\n\n  /**\n   * Sorts the elements of a sequence in descending order according to a key\n   * by using a specified comparer.\n   *\n   * @param keySelector  A function to extract a key from an element.\n   * @param comparer     A function to compare the keys\n   *\n   * @example\n   * ```typescript\n   * // Returns a Sequence of 3, 2, 1\n   * from([1, 3, 2]).sortByDescending()\n   * ```\n   */\n  sortByDescending<TKey = TItem>(\n    keySelector?: KeySelectorFn<TItem, TKey>,\n    comparer?: ComparerFn<TKey>\n  ): OrderedSequence<TItem> {\n    const compareFn = createCompareFn(true, keySelector, comparer);\n\n    return new OrderedSequence(this._iterable, compareFn);\n  }\n\n  /**\n   * Sums the elements in the sequence.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns 6\n   * from([1, 2, 3]).sum();\n   * ```\n   */\n  sum<TItem extends number>(): number;\n  /**\n   * Sums the elements in the sequence\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @example\n   * ```typescript\n   * // Returns \"abc\"\n   * from([\"a\", \"b\", \"c\"]).sum();\n   * ```\n   */\n  sum<TItem extends string>(): string;\n  /**\n   * Maps the elements in the sequence using the valueSelector and sums them\n   * together.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @param valueSelector  A function to select a value from an element.\n   *\n   * @example\n   * ```typescript\n   * // Returns 2\n   * from([true, false, true]).sum(x => x ? 1 : 0);\n   * ```\n   */\n  sum<TResult extends number>(valueSelector: MapFn<TItem, TResult>): number;\n  /**\n   * Maps the elements in the sequence using the valueSelector and sums them\n   * together.\n   * NOTE! If the sequence is empty, 0 is returned.\n   *\n   * @param valueSelector  A function to select a value from an element.\n   *\n   * @example\n   * ```typescript\n   * // Returns \"101\"\n   * from([true, false, true]).sum(x => x ? \"1\" : \"0\");\n   * ```\n   */\n  sum<TResult extends string>(valueSelector: MapFn<TItem, TResult>): string;\n  sum<TResult>(valueSelector?: MapFn<TItem, TResult>): number | string {\n    let result: any | undefined = undefined;\n\n    for (const item of this._iterable) {\n      let itemToSum = valueSelector ? valueSelector(item) : item;\n\n      if (result === undefined) {\n        result = itemToSum as any;\n      } else {\n        result +=\n          typeof (itemToSum as unknown) === \"number\"\n            ? itemToSum\n            : String(itemToSum);\n      }\n    }\n\n    return result === undefined ? 0 : result;\n  }\n\n  /**\n   * Takes the firt N items from the sequence\n   *\n   * @example\n   * ```typescript\n   * // Returns [1, 2]\n   * from([1, 2, 3, 4]).take(2);\n   * ```\n   */\n  take(howMany: number): Sequence<TItem> {\n    return this._sequenceFromGenerator<TItem>(take, [howMany]);\n  }\n\n  /**\n   * Returns elements from a sequence as long as a specified condition is true,\n   * and then skips the remaining elements.\n   *\n   * @param predicate  A function to test each element for a condition.\n   *\n   * @example\n   * ```ts\n   * // Returns [1, 2]\n   * from([1, 2, 3, 4, 5])\n   *   .takeWhile(i => i < 3)\n   *   .toArray();\n   * ```\n   */\n  takeWhile(predicate: PredicateFn<TItem>) {\n    return this._sequenceFromGenerator<TItem>(takeWhile, [predicate]);\n  }\n\n  /**\n   * Returns elements from a sequence as long as they don't exist in the specified iterable items.\n   *\n   * @param items     The provided set of items that should not be in the returned Sequence.\n   * @param predicate The optional predicate that determines if two TItem items are equal.\n   *\n   * @example\n   * ```ts\n   * // returns [2, 4, 6]\n   * from([1, 2, 3, 4, 5, 6])\n   *   .without([1, 3, 5])\n   *   .toArray();\n   *\n   * // returns [{ id: 1 }, { id: 3 }]\n   * from([{ id: 1 }, { id: 2 }, { id: 3 }])\n   *   .without([{ id: 2 }], (a, b) => a.id === b.id)\n   *   .toArray();\n   * ```\n   */\n  without(\n    items: Iterable<TItem>,\n    predicate?: ComparePredicate<TItem>\n  ): Sequence<TItem> {\n    if (!predicate) {\n      const withoutSet = new Set(items);\n      return this.filter((item: TItem) => !withoutSet.has(item));\n    } else {\n      return this._sequenceFromGenerator<TItem>(without, [items, predicate]);\n    }\n  }\n\n  /**\n   * Converts the sequence to an array\n   *\n   * @example\n   * ```typescript\n   * // Return [1, 2, 3]\n   * from([1, 2, 3]).toArray();\n   * ```\n   */\n  toArray(): TItem[] {\n    return copyIntoAnArray(this._iterable);\n  }\n\n  /**\n   * Converts the sequence to a Map using the given keySelectorFn and\n   * possible elementSelectorFn.\n   *\n   * @example\n   * ```typescript\n   * // Returns map with elements:\n   * // 1 -> { id: 1, name: \"John\" }\n   * // 2 -> { id: 2, name: \"Jane\"}\n   * const users = [{ id: 1, name: \"John\" }, { id: 2, name: \"Jane\"}]\n   * from(users).toMap(u => u.id);\n   * ```\n   *\n   * @param keySelectorFn\n   * @param elementSelectorFn\n   */\n  toMap<TKey, TElement = TItem>(\n    keySelectorFn: MapFn<TItem, TKey>,\n    elementSelectorFn?: MapFn<TItem, TElement>\n  ): Map<TKey, TElement> {\n    const map = new Map<TKey, TElement>();\n\n    for (const item of this._iterable) {\n      const key = keySelectorFn(item);\n      const value = elementSelectorFn ? elementSelectorFn(item) : item;\n\n      map.set(key, value as TElement);\n    }\n\n    return map;\n  }\n\n  /**\n   * Converts the sequence to an object using the given keySelectorFn and\n   * possible elementSelectorFn.\n   *\n   * @example\n   * ```typescript\n   * // Returns an object:\n   * // {\n   * //   \"John\": { id: 1, name: \"John\" },\n   * //   \"Jane\": { id: 2, name: \"Jane\"}\n   * // }\n   * const users = [{ id: 1, name: \"John\" }, { id: 2, name: \"Jane\"}]\n   * from(users).toObject(u => u.name);\n   * ```\n   *\n   * @param keySelectorFn\n   * @param elementSelectorFn\n   */\n  toObject(keySelectorFn: MapFn<TItem, string>): StringKeyedObject<TItem>;\n  toObject(keySelectorFn: MapFn<TItem, number>): NumberKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, string>,\n    elementSelectorFn: MapFn<TItem, TElement>\n  ): StringKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, number>,\n    elementSelectorFn: MapFn<TItem, TElement>\n  ): NumberKeyedObject<TItem>;\n  toObject<TElement>(\n    keySelectorFn: MapFn<TItem, string> | MapFn<TItem, number>,\n    elementSelectorFn?: MapFn<TItem, TElement>\n  ):\n    | StringKeyedObject<TItem>\n    | NumberKeyedObject<TItem>\n    | StringKeyedObject<TElement>\n    | NumberKeyedObject<TElement> {\n    const object: any = {};\n\n    for (const item of this._iterable) {\n      const key = keySelectorFn(item);\n      const value = elementSelectorFn ? elementSelectorFn(item) : item;\n\n      object[key] = value;\n    }\n\n    return object;\n  }\n\n  /**\n   * Converts the sequence to a Set\n   *\n   * @example\n   * ```typescript\n   * // Return a Set with elements 1, 2, 3\n   * from([1, 1, 2, 3]).toSet();\n   * ```\n   */\n  toSet(): Set<TItem> {\n    return new Set(this._iterable);\n  }\n\n  private _sequenceFromGenerator<TResult = TItem>(\n    factoryFn: Function,\n    restArgs?: any[]\n  ) {\n    const iterableArg = [this._iterable];\n\n    return new Sequence<TResult>(\n      iterableFromGenerator<TResult>(\n        factoryFn,\n        restArgs ? iterableArg.concat(restArgs) : iterableArg\n      )\n    );\n  }\n}\n\n/**\n * Ordered sequence of elements\n */\nexport class OrderedSequence<TItem> extends Sequence<TItem> {\n  private _comparer: ComparerFn<TItem>;\n\n  constructor(\n    private _iterableToSort: Iterable<TItem>,\n    comparer: ComparerFn<TItem>\n  ) {\n    super(iterableFromGenerator(sortBy, [_iterableToSort, comparer]));\n\n    this._comparer = comparer;\n  }\n\n  thenBy<TOtherKey>(\n    keySelector: KeySelectorFn<TItem, TOtherKey>,\n    comparer?: ComparerFn<TOtherKey>\n  ): OrderedSequence<TItem> {\n    const thenComparer = createCompareFn(false, keySelector, comparer);\n    const compareFn = createChainedCompareFn(this._comparer, thenComparer);\n\n    return new OrderedSequence(this._iterableToSort, compareFn);\n  }\n\n  thenByDescending<TOtherKey>(\n    keySelector: KeySelectorFn<TItem, TOtherKey>,\n    comparer?: ComparerFn<TOtherKey>\n  ): OrderedSequence<TItem> {\n    const thenComparer = createCompareFn(true, keySelector, comparer);\n    const compareFn = createChainedCompareFn(this._comparer, thenComparer);\n\n    return new OrderedSequence(this._iterableToSort, compareFn);\n  }\n}\n\n/**\n * Creates a compare function that sorts TItems either ascending or descending\n * using the given key selector and comparer.\n *\n * @param descending  Sort descending or ascending\n * @param keySelector Optional function to select the key that is used for sorting\n * @param comparer    Optional comparer function to compare the keys\n */\nconst createCompareFn = <TItem, TKey>(\n  descending: boolean,\n  keySelector?: KeySelectorFn<TItem, TKey>,\n  comparer?: ComparerFn<TKey>\n) => {\n  const compareFn = comparer || defaultComparer;\n\n  return keySelector\n    ? (a: TItem, b: TItem) =>\n        descending\n          ? compareFn(keySelector(b), keySelector(a))\n          : compareFn(keySelector(a), keySelector(b))\n    : (a: TItem, b: TItem) =>\n        descending ? defaultComparer(b, a) : defaultComparer(a, b);\n};\n\n/**\n * Chains two compare functions. First sort by firstCompare. If items\n * are equal, then sorts by secondCompare.\n *\n * @param firstCompare\n * @param secondCompare\n */\nconst createChainedCompareFn = <TItem>(\n  firstCompare: ComparerFn<TItem>,\n  secondCompare: ComparerFn<TItem>\n) => (a: TItem, b: TItem) => {\n  const firstResult = firstCompare(a, b);\n\n  return firstResult === 0 ? secondCompare(a, b) : firstResult;\n};\n\nconst createSelectByKey = <TItem>(key: string) => (item: TItem) =>\n  key in item ? (item as any)[key] : undefined;\n","import { NumberKeyedObject, StringKeyedObject } from \"./types\";\nimport { iterableFromGenerator } from \"./utils\";\n\n/**\n * Creates an iterable from object, that iterates the object\n * as key value pairs.\n */\nexport function createObjectIterable<T>(\n  object: NumberKeyedObject<T>\n): Iterable<[number, T]>;\nexport function createObjectIterable<T>(\n  object: StringKeyedObject<T>\n): Iterable<[string, T]>;\nexport function createObjectIterable<T>(\n  object: StringKeyedObject<T> | NumberKeyedObject<T>\n): any {\n  return iterableFromGenerator(objectIterator, [object]);\n}\n\nfunction* objectIterator(object: any) {\n  for (const key in object) {\n    if (object.hasOwnProperty(key)) {\n      const value = object[key];\n\n      yield [key, value] as any;\n    }\n  }\n}\n","/**\n * Entrypoint of the library\n */\nimport { Sequence } from \"./Sequence\";\nimport { createObjectIterable } from \"./ObjectIterable\";\nimport { StringKeyedObject, NumberKeyedObject } from \"./types\";\n\nexport function from<T>(iterable: Iterable<T>): Sequence<T>;\nexport function from<T>(object: StringKeyedObject<T>): Sequence<[string, T]>;\nexport function from<T>(object: NumberKeyedObject<T>): Sequence<[number, T]>;\nexport function from<T>(\n  iterable: Iterable<T> | StringKeyedObject<T> | NumberKeyedObject<T>\n): Sequence<T> | Sequence<[string, T]> | Sequence<[number, T]> {\n  if (iterable instanceof Sequence) {\n    return iterable;\n  } else if (_isIterable(iterable)) {\n    return new Sequence(iterable);\n  } else {\n    return new Sequence(createObjectIterable(iterable));\n  }\n}\n\nfunction _isIterable<T>(object: any): object is Iterable<T> {\n  return typeof object[Symbol.iterator] === \"function\";\n}\n"],"names":["concat","source","others","other","distinct","iterable","unique","Set","item","has","add","filter","predicate","flatMap","mapperFn","sequence","groupBy","keySelector","elementSelector","groups","Map","key","value","group","get","set","push","keyItemsPair","entries","items","map","mapFn","prepend","copyIntoAnArray","Array","isArray","slice","result","iterableFromGenerator","generatorFn","args","[object Object]","Symbol","iterator","apply","undefined","reverse","i","length","skip","howMany","numSkipped","skipWhile","startTaking","sortBy","comparer","sort","take","numTaken","takeWhile","without","withoutItems","comparePredicate","cache","outer","withoutItem","identityPredicateFn","x","defaultComparer","a","b","Sequence","_iterable","this","_sequenceFromGenerator","callback","createSelectByKey","searchItem","some","toArray","keys","accumulator","compareFn","createCompareFn","OrderedSequence","valueSelector","itemToSum","String","withoutSet","keySelectorFn","elementSelectorFn","object","factoryFn","restArgs","iterableArg","_iterableToSort","super","_comparer","thenComparer","createChainedCompareFn","descending","firstCompare","secondCompare","firstResult","objectIterator","hasOwnProperty","createObjectIterable"],"mappings":"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"}